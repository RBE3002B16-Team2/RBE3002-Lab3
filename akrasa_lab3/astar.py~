#!/usr/bin/env python
import rospy
from nav_msgs.msg import GridCells, Path
from std_msgs.msg import String
from geometry_msgs.msg import Twist, Point, Pose, PoseStamped, PoseWithCovarianceStamped
from nav_msgs.msg import Odometry, OccupancyGrid
from kobuki_msgs.msg import BumperEvent
from tf.transformations import quaternion_from_euler
import tf
import numpy
import math
import rospy, tf, numpy, math

class Node:
	def __init__(self,value, point, start, goal):
		self.value = value
		self.point = point
		self.parent = None
		self.H = start
		self.G = goal
		
	def children(point,grid):
		x,y = point.point
		links = [grid[d[0]][d[1]] for d in [(x-1, y),(x,y - 1),(x,y + 1),(x+1,y)]]
		return [link for link in links if link.value != '%']

	def manhattan(point,point2):
		return abs(point.point[0] - point2.point[0]) + abs(point.point[1]-point2.point[0])

def getLowestF(openset):
	lowest = openSet[0]
	for i in range(0,len(openSet)):
		if( (i.G + i.H) < (lowest.G + lowest.H) ):
			lowest = i
	return lowest


def copyMap(data):
	global mapGrid
	global mapData
	global width
	global height
	global mapgrid
	global resolution
	global offsetX
	global offsetY
	mapGrid = data
	resolution = data.info.resolution
	mapData = data.data
	width = data.info.width
	height = data.info.height
	offsetX = data.info.origin.position.x
	offsetY = data.info.origin.position.y
	initGrid(mapGrid)




def aStar(start, goal, grid):
	global resolution
	global offsetX
	global offsetY
	global startPosX
	global startPosY

	print "astar called"
	#The open and closed sets
	openset = set()
	closedset = set()
	#Current point is the starting point

	
	print startPosX
	j = int((pose.position.x - offsetX - (.5 * resolution)) / resolution)
	i = int((pose.position.y - offsetY - (.5 * resolution)) / resolution)
	

	print "start"


def next_move(pacman,food,grid):
	#Convert all the points to instances of Node
	for x in xrange(len(grid)):
		for y in xrange(len(grid[x])):
			grid[x][y] = Node(grid[x][y],(x,y))
	#Get the path
	path = aStar(grid[pacman[0]][pacman[1]],grid[food[0]][food[1]],grid)
	#Output the path
	print len(path) - 1
	for node in path:
		x, y = node.point
		print x, y
	pacman_x, pacman_y = [ int(i) for i in raw_input().strip().split() ]
	food_x, food_y = [ int(i) for i in raw_input().strip().split() ]
	x,y = [ int(i) for i in raw_input().strip().split() ] 
	grid = []

	for i in xrange(0, x):
		grid.append(list(raw_input().strip()))
		next_move((pacman_x, pacman_y),(food_x, food_y), grid)
